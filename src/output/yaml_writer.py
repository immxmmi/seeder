from pathlib import Path
from typing import Dict, List, Any, Optional

import yaml
from utils.logger import Logger as log


class YamlWriter:
    """Writes collected data to an inputs.yaml file with diff detection."""

    @staticmethod
    def load_existing(output_path: Path) -> Optional[Dict[str, Any]]:
        """Load existing inputs.yaml if it exists."""
        if not output_path.exists():
            return None

        try:
            content = output_path.read_text()
            data = yaml.safe_load(content)
            return data if data else None
        except yaml.YAMLError as e:
            log.warn("YamlWriter", f"Failed to parse existing {output_path}: {e}")
            return None

    @staticmethod
    def diff(existing: Dict[str, Any], new_data: Dict[str, Any]) -> List[str]:
        """Compare existing and new data, return list of change descriptions."""
        changes = []

        all_keys = set(list(existing.keys()) + list(new_data.keys()))

        for key in sorted(all_keys):
            old_items = existing.get(key, [])
            new_items = new_data.get(key, [])

            if not isinstance(old_items, list):
                old_items = []
            if not isinstance(new_items, list):
                new_items = []

            if key not in existing:
                changes.append(f"  + [{key}] new section with {len(new_items)} item(s)")
                continue

            if key not in new_data:
                changes.append(f"  - [{key}] section removed ({len(old_items)} item(s))")
                continue

            old_by_name = {item.get("name", f"__idx_{i}"): item for i, item in enumerate(old_items)}
            new_by_name = {item.get("name", f"__idx_{i}"): item for i, item in enumerate(new_items)}

            all_names = set(list(old_by_name.keys()) + list(new_by_name.keys()))

            for name in sorted(all_names):
                if name not in old_by_name:
                    changes.append(f"  + [{key}] added: {name}")
                elif name not in new_by_name:
                    changes.append(f"  - [{key}] removed: {name}")
                elif old_by_name[name] != new_by_name[name]:
                    old_item = old_by_name[name]
                    new_item = new_by_name[name]
                    changed_fields = []
                    all_fields = set(list(old_item.keys()) + list(new_item.keys()))
                    for field in sorted(all_fields):
                        if old_item.get(field) != new_item.get(field):
                            changed_fields.append(field)
                    changes.append(f"  ~ [{key}] changed: {name} ({', '.join(changed_fields)})")

        return changes

    @staticmethod
    def write(output_path: Path, data: Dict[str, List[Dict[str, Any]]]) -> bool:
        """Write data to YAML file. Returns True if file was updated, False if unchanged.

        Args:
            output_path: Path to the output YAML file.
            data: Dictionary with target_keys as keys and lists of dicts as values.
        """
        existing = YamlWriter.load_existing(output_path)

        if existing is not None:
            changes = YamlWriter.diff(existing, data)
            if not changes:
                log.info("YamlWriter", f"No changes detected, {output_path} is up to date")
                return False

            log.info("YamlWriter", f"Changes detected in {output_path}:")
            for change in changes:
                log.info("YamlWriter", change)
        else:
            log.info("YamlWriter", f"Creating new file: {output_path}")

        output_path.parent.mkdir(parents=True, exist_ok=True)

        total_items = sum(len(v) for v in data.values())
        log.info("YamlWriter", f"Writing {total_items} item(s) to {output_path}")

        with open(output_path, "w") as f:
            f.write("# Auto-generated by seeder\n")
            f.write("# Do not edit manually - changes will be overwritten\n\n")
            yaml.dump(data, f, default_flow_style=False, allow_unicode=True, sort_keys=False)

        log.info("YamlWriter", f"Successfully wrote {output_path}")
        return True
