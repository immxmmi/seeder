# Seeder

> Saet die Daten, die die Provisioner ernten.

Seeder ist der Daten-Zulieferer fuer die PipelineExecutionPlatform. Er fragt externe Systeme (CMDBs, Jira, Kubernetes, beliebige REST APIs) ab, transformiert die Antworten per konfigurierbarem Mapping und schreibt das Ergebnis als `inputs.yaml` im Format das die Provisioner (`acs-provisioner`, `quay-provisioner`) erwarten.

Seeder ist nicht event-basiert sondern laeuft periodisch (z.B. als K8s CronJob), vergleicht die neuen Daten mit dem aktuellen Stand und schreibt nur bei Aenderungen.

## Wie es funktioniert

```
  Externe APIs (CMDB, Jira, ...)
           |
           v
    +-------------+
    |  Collector   |  Holt Rohdaten per REST
    +-------------+
           |
           v
    +-------------+
    |   Mapping    |  API-Felder → Provisioner-Felder
    +-------------+
           |
           v
    +-------------+
    |    Diff      |  Vergleich mit bestehender inputs.yaml
    +-------------+
           |
      Aenderungen?
      /         \
    Nein        Ja
     |           |
   (skip)    Schreibt inputs.yaml
```

## Beispiel: Schritt fuer Schritt

Angenommen eine CMDB liefert Jira-Notifier-Daten ueber eine REST API.
So richtet man Seeder ein, um daraus automatisch die `inputs.yaml` fuer den `acs-provisioner` zu erzeugen.

### 1. Source-Datei anlegen

Jede Datenquelle bekommt eine eigene YAML-Datei unter `src/config/sources/`.
Hier wird definiert: wo die API ist, wie man sich authentifiziert, und wie die Felder gemappt werden.

`src/config/sources/jira-notifiers.yaml`:

```yaml
name: "jira-notifiers"
enabled: true

# --- Verbindung zur API ---
connection:
  host: "https://cmdb.example.com"
  auth_type: "bearer"
  token_env: "CMDB_TOKEN"           # Token kommt aus Umgebungsvariable
  endpoint: "/api/v1/notifiers"

# --- Wo landen die Daten in der inputs.yaml ---
target_key: "notifiers"

# --- Feld-Mapping ---
# Links: Feldname wie ihn die API liefert
# Rechts: Feldname wie ihn der acs-provisioner erwartet
mapping:
  title: "name"
  notification_type: "type"
  ui_endpoint: "uiEndpoint"
  label_key: "labelKey"
  label_default: "labelDefault"
  config: "jira"                     # verschachteltes Objekt wird 1:1 uebernommen

# --- Statische Werte die jeder Eintrag bekommt ---
defaults:
  traits:
    mutabilityMode: "ALLOW_MUTATE"
    visibility: "VISIBLE"
    origin: "IMPERATIVE"
```

### 2. API-Token setzen

```bash
cp .env.example .env
```

In der `.env` den Token eintragen (der Name muss zu `token_env` in der Source passen):

```
CMDB_TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

### 3. Seeder starten

```bash
make run
```

### 4. Was passiert

Die API `https://cmdb.example.com/api/v1/notifiers` liefert z.B.:

```json
[
  {
    "title": "Jira-Security",
    "notification_type": "jira",
    "ui_endpoint": "https://acs.example.com",
    "label_key": "notifier.jira",
    "label_default": "Jira Security Notifier",
    "config": {
      "url": "https://jira.example.com",
      "username": "acs-service",
      "password": "api-token-xyz",
      "issueType": "Bug"
    },
    "internal_id": "abc-123",
    "created_at": "2025-01-15",
    "updated_by": "admin"
  }
]
```

Seeder wendet das Mapping an. Nur gemappte Felder werden uebernommen, der Rest (`internal_id`, `created_at`, `updated_by`) faellt weg:

```yaml
# Auto-generated by seeder

notifiers:
- name: Jira-Security                  # war "title"
  type: jira                            # war "notification_type"
  uiEndpoint: https://acs.example.com   # war "ui_endpoint"
  labelKey: notifier.jira               # war "label_key"
  labelDefault: Jira Security Notifier  # war "label_default"
  jira:                                 # war "config"
    url: https://jira.example.com
    username: acs-service
    password: api-token-xyz
    issueType: Bug
  traits:                               # aus "defaults" (statisch)
    mutabilityMode: ALLOW_MUTATE
    visibility: VISIBLE
    origin: IMPERATIVE
```

Diese Datei kann der `acs-provisioner` direkt als `inputs.yaml` verwenden.

### 5. Beim naechsten Lauf

Seeder vergleicht die neuen API-Daten mit der bestehenden `inputs.yaml`:

```
No changes detected, inputs.yaml is up to date
```

Oder bei Aenderungen:

```
Changes detected:
  ~ [notifiers] changed: Jira-Security (uiEndpoint, labelDefault)
  + [notifiers] added: Splunk-SIEM
  - [notifiers] removed: Old-Email-Notifier
```

Nur bei Aenderungen wird die Datei neu geschrieben.

## Quickstart

```bash
make install                              # Abhaengigkeiten + pytest
cp .env.example .env                      # Tokens setzen
# Source-Dateien anlegen/anpassen unter src/config/sources/*.yaml
make run                                  # Seeder starten
```

### Docker

```bash
docker build -t seeder .
docker run --env-file .env seeder
```

### Makefile

```bash
make install        # Abhaengigkeiten + pytest
make run            # Seeder starten
make test           # Alle Tests
make test-mapping   # Nur Mapping-Tests
make test-diff      # Nur Diff-Tests
make build          # Docker Image bauen
make clean          # __pycache__ aufraeumen
```

## Konfiguration

### Globale Settings (`src/config/settings.yaml`)

```yaml
output:
  file: "../acs-provisioner/src/pipelines/inputs.yaml"

debug:
  enabled: false

app:
  version: "1.0.0"
```

### Source-Dateien (`src/config/sources/*.yaml`)

Jede Datenquelle bekommt eine eigene Datei. Seeder laedt alle `*.yaml` aus dem Ordner automatisch.

```yaml
name: "meine-quelle"                  # Eindeutiger Name
enabled: true                          # false = wird uebersprungen

connection:
  host: "https://api.example.com"      # Basis-URL
  auth_type: "bearer"                  # bearer | basic | apikey
  token_env: "MY_API_TOKEN"           # Name der Umgebungsvariable
  endpoint: "/api/v1/data"            # API-Pfad

target_key: "notifiers"               # Key in der output inputs.yaml

mapping:                               # API-Feld -> Output-Feld
  api_field_name: "output_field_name"

defaults:                              # Statische Werte pro Item
  key: "value"
```

### Umgebungsvariablen

| Variable | Beschreibung | Default |
|---|---|---|
| `CMDB_TOKEN` | API-Token (Name konfigurierbar via `token_env`) | - |
| `OUTPUT_FILE` | Ueberschreibt den Output-Pfad | aus settings.yaml |
| `DISABLE_TLS_VERIFY` | TLS-Verifikation deaktivieren | `false` |
| `CA_BUNDLE` | Pfad zu eigenem CA-Bundle | - |
| `DEBUG_ENABLED` | Debug-Logging aktivieren | `false` |
| `API_TIMEOUT` | HTTP-Timeout in Sekunden | `30` |

## Mapping im Detail

### Whitelist-Prinzip

Wenn `mapping` definiert ist, landen **nur** die gemappten Felder im Output. Alles andere wird ignoriert. Das verhindert, dass interne API-Felder in der `inputs.yaml` landen.

```yaml
mapping:
  title: "name"              # API "title" -> Output "name"
  notification_type: "type"  # API "notification_type" -> Output "type"
# API-Feld "internal_id" ist nicht im Mapping -> wird ignoriert
```

### Ohne Mapping

Ohne `mapping` (oder `mapping: {}`) werden alle Felder 1:1 durchgereicht.

### Defaults

`defaults` fuegt jedem Item statische Werte hinzu. Werte von der API haben Vorrang:

```yaml
defaults:
  traits:
    mutabilityMode: "ALLOW_MUTATE"
# Wenn die API selbst ein "traits"-Feld liefert UND es gemappt ist,
# wird der API-Wert verwendet, nicht der Default.
```

## Diff-Erkennung

Beim Schreiben vergleicht Seeder die neuen Daten mit der bestehenden `inputs.yaml`:

```
  + [notifiers] added: Splunk-SIEM           Neues Item
  - [notifiers] removed: Old-Notifier        Item entfernt
  ~ [notifiers] changed: Jira-Security (url) Feld geaendert
```

- Keine Aenderungen -> Datei wird nicht angefasst
- Aenderungen -> Diff wird geloggt, Datei wird ueberschrieben

## Projektstruktur

```
seeder/
├── CLAUDE.md
├── README.md
├── Dockerfile
├── Makefile
├── requirements.txt
├── .env.example
├── tests/
│   ├── test_transform.py          # Mapping-Tests
│   └── test_diff.py               # Diff-Tests
└── src/
    ├── main.py                    # Entry Point
    ├── config/
    │   ├── loader.py              # Config Singleton
    │   ├── settings.yaml          # Globale Settings
    │   └── sources/               # Eine YAML pro Datenquelle
    │       ├── jira-notifiers.yaml
    │       └── image-integrations.yaml
    ├── gateway/
    │   └── client.py              # HTTP Client (Bearer/Basic/APIKey, TLS)
    ├── collectors/
    │   ├── base_collector.py      # Abstrakte Basisklasse
    │   └── generic_collector.py   # REST API Collector + Mapping
    ├── models/
    │   ├── notifier_input.py      # Pydantic Model (Notifier)
    │   └── integration_input.py   # Pydantic Model (Integration)
    ├── output/
    │   └── yaml_writer.py         # YAML-Ausgabe mit Diff-Erkennung
    └── utils/
        ├── display.py             # Banner + Summary Ausgabe
        └── logger.py              # Farbiger Logger
```

## Erweiterung

Neue Collector-Typen koennen hinzugefuegt werden:

```python
from collectors.base_collector import BaseCollector

class JiraCollector(BaseCollector):
    def collect(self):
        # Jira-spezifische Logik
        ...
```

Der `GenericCollector` deckt bereits alle REST APIs ab die JSON zurueckliefern.
